// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4980.SteamworksAliceRobot2017.commands;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Command;

import org.usfirst.frc4980.SteamworksAliceRobot2017.RobotMap;
import org.usfirst.frc4980.SteamworksAliceRobot2017.OI;
import org.usfirst.frc4980.SteamworksAliceRobot2017.Robot;
import com.kauailabs.navx.frc.*;
/**
 *
 */
public class driveMecanum extends Command {
	public static final int
    LEFT_X_AXIS = 0,
    LEFT_Y_AXIS = 1,
    TRIGGERS = 3,
    RIGHT_X_AXIS = 4,
    RIGHT_Y_AXIS = 5,
    DPAD_LR = 6;
	private static final double DAMPER_SPEED = 0.5;
	

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public driveMecanum() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    	requires(Robot.drivebase);
      
    }

    // Called just before this Command runs the first time
    protected void initialize() {  	
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	 Joystick j = Robot.oi.joystick;
    	 AHRS ahrs = Robot.ahrs;
    	 boolean driveCartesian = false;
    	 if(j.getIsXbox()){
    		if(j.getRawAxis(3)>0.25){
    			driveCartesian = true;

    		}
    	 }
    	 
    	double x,y,z;
    	double K = 0.5; // This is a rotational constant
    	double deadZone = 0.15;
    	double deadZoneRotation = 0.25;
    	double maxSpeed = 1.0;
    	double right, forward, clockwise; 
         if(j.getIsXbox()) {
//        	 forward = (j.getRawAxis(LEFT_Y_AXIS) + j.getRawAxis(RIGHT_Y_AXIS))/2.0;
//        	 right = ((j.getRawAxis(LEFT_X_AXIS)+ j.getRawAxis(RIGHT_X_AXIS))/2.0);
        	 forward = -j.getRawAxis(LEFT_Y_AXIS);
        	 right = j.getRawAxis(LEFT_X_AXIS);
        	 clockwise = j.getRawAxis(RIGHT_X_AXIS);
        	 if(j.getRawButton(5)){//xbox left bumper 
        		 maxSpeed = DAMPER_SPEED;
        	 }
        	 K = 0.4;
//        	 if(j.getRawAxis(LEFT_Y_AXIS)< 0 && j.getRawAxis(RIGHT_Y_AXIS)> 0) {
//        		 clockwise = -0.5;
//        	 }else if(j.getRawAxis(LEFT_Y_AXIS)> 0 && j.getRawAxis(RIGHT_Y_AXIS)< 0){
//        		 clockwise = 0.5;
//        	 } else {
//        		 clockwise = 0;
//        	 }
         } else {
        	  right = j.getX();
        	  forward = -j.getY();
              clockwise = j.getTwist(); 
              if(j.getRawButton(11)){
            	  maxSpeed = DAMPER_SPEED;
              }
         }
        
        
    	 if(Math.abs(right)<deadZone){
    		 right = 0.0;
    	 }
    	 if(Math.abs(forward)<deadZone) {
    		 forward = 0.0;
    	 }
    	 if(Math.abs(clockwise)<deadZoneRotation){
    		 clockwise = 0.0;
    	 }
    	if(driveCartesian){
    		RobotMap.drivebaseRobotDrive41.mecanumDrive_Cartesian(right, forward, clockwise, Robot.ahrs.getAngle());
    	} else {
    		
    	
    	clockwise = K*clockwise;
    	//Un comment this for field orientation using gyro note: un tested
    	//double theta = Math.toRadians(ahrs.getAngle()-Robot.startingAngle);
    	//double temp = forward*Math.cos(theta) + right*Math.sin(theta);
    	//right = -forward*Math.sin(theta) + right*Math.cos(theta);
    	//forward = temp;
    	
    	double frontLeft = forward + clockwise + right;
    	double frontRight = forward - clockwise - right;
    	double rearLeft = forward + clockwise - right;
    	double rearRight = forward - clockwise + right;
    	
    	double max = Math.abs(frontLeft);
    	if(Math.abs(frontRight)> max)
    		max = Math.abs(frontRight);
    	if(Math.abs(rearLeft)> max)
    		max = Math.abs(rearLeft);
    	if(Math.abs(rearRight)>max)
    		max = Math.abs(rearRight);
    	
    	if(max>maxSpeed)
    	{
    		frontLeft/=max;
    		frontRight/=max;
    		rearLeft/=max;
    		rearRight/=max;
    	}
    	if(Robot.drivebase.invert){
    		RobotMap.drivebasebackLeftMotor.set(-rearLeft);
        	RobotMap.drivebasebackRightMotor.set(-rearRight);
        	//RobotMap.drivebasebackLeftMotor2.set(rearLeft);
        	//RobotMap.drivebasebackRightMotor2.set(rearRight);
        	RobotMap.drivebasefrontLeftMotor.set(-frontLeft);
        	RobotMap.drivebasefrontRightMotor.set(-frontRight);
    	} else {
    		RobotMap.drivebasebackLeftMotor.set(rearLeft);
        	RobotMap.drivebasebackRightMotor.set(rearRight);
        	//RobotMap.drivebasebackLeftMotor2.set(rearLeft);
        	//RobotMap.drivebasebackRightMotor2.set(rearRight);
        	RobotMap.drivebasefrontLeftMotor.set(frontLeft);
        	RobotMap.drivebasefrontRightMotor.set(frontRight);
    	}
    	
    }
//    	double rcw = xBox.getRawAxis(RIGHT_X_AXIS);
//    	double forwrd = xBox.getRawAxis(LEFT_Y_AXIS) * -1; /* Invert stick Y axis */
//    	double strafe = xBox.getRawAxis(LEFT_X_AXIS);
//    	 
//    	float pi = 3.1415926;
//    	 
    	/* Adjust Joystick X/Y inputs by navX MXP yaw angle */
    	 
//    	double gyro_degrees = ahrs->GetYaw();
//    	float gyro_radians = gyro_degrees * pi/180; 
//    	float temp = forwrd * cos(gyro_radians) + 
//    	 strafe * sin(gyro_radians);
//    	strafe = -forwrd * sin(gyro_radians) + 
//    	 strafe * cos(gyro_radians);
//    	forwrd = temp;
        

        
        //double yRight = jxBox.getRawAxis(RIGHT_Y_AXIS);
        
        //MECANUM CARTESIAN
        //x: The speed that the robot should drive in the X direction. [-1.0..1.0]y The speed that the robot should drive in the 
        //Y: direction. This input is inverted to match the forward == -1.0 that joysticks produce. [-1.0..1.0]
        //rotation: The rate of rotation for the robot that is completely independent of the translation. [-1.0..1.0]
        //gyroAngle: The current angle reading from the gyro. Use this to implement field-oriented controls.
        //RobotMap.driveBaseRobotDrive41.mecanumDrive_Cartesian(x, y, rotation, gyroAngle);
       // RobotMap.drivebaseRobotDrive41.mecanumDrive_Cartesian(strafe, forwrd, rcw, Robot.ahrs.getAngle());
       // RobotMap.drivebaseRobotDrive41.mecanumDrive_Cartesian(j3D.getX(), j3D.getY(), j3D.getTwist(), 0.0);
        
        //MECANUM POLAR
        //magnitude: The speed that the robot should drive in a given direction.
        //direction: The direction the robot should drive in degrees. The direction and maginitute are independent of the rotation rate.rotation 
        //rotation: The rate of rotation for the robot that is completely independent of the magnitute or direction. [-1.0..1.0]
        //RobotMap.driveBaseRobotDrive41.mecanumDrive_Polar(magnitude, direction, rotation);
        //RobotMap.drivebaseRobotDrive41.mecanumDrive_Polar(x,y,z);
        //RobotMap.driveBaseRobotDrive41.mecanumDrive_Polar(j3D.getX(), j3D.getY(), j3D.getTwist());
        
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
}

